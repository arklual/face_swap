## Контекст и цель

Нужно интегрировать скрипт вёрстки/рендера из `html_render.py` и требования из `ts.txt` в существующий `backend/` так, чтобы:

- **Все входные ассеты и все результаты хранились в S3** (S3-совместимое хранилище: Yandex Object Storage, VK Cloud, MinIO и т.п.).
- **Тяжёлые операции выполнялись асинхронно** (Celery уже есть), а FastAPI выступал как “control plane”.
- **Фронтенд из репозитория не используется** (ориентируемся на API/интеграцию с внешними системами).
- **Пайплайн был странично-конфигурируемым**: на каждой странице может быть только face swap, только текст, и то и то, либо ничего.
- **Генерация была двухфазной**: до оформления заказа/оплаты генерируем только первые 2 страницы (free preview), после оплаты — полный комплект.

Этот документ — **выводы по текущему проекту + подробный план реализации** (без внесения кода).

---

## Что уже есть в проекте (важное для интеграции)

### Сервисы и стек (по `docker-compose.yml`)

- **FastAPI**: сервис `web` (`backend/app/main.py`), отдает API.
- **Celery worker**: сервис `celery_worker` (очереди `gpu,celery`), подключен к Redis.
- **Postgres**: сервис `db`, хранит сущности каталога/заказов/персонализаций.
- **Redis**: брокер/бекенд для Celery.
- **ComfyUI**: сервис `comfyui` (GPU), используется для инференса/face transfer.
- `frontend` сервис в compose есть, но по требованиям **его не учитываем**.

### S3 уже используется (и это хорошо)

- Конфиг S3 в `backend/app/config.py` и `backend/env.example`:
  - `AWS_ENDPOINT_URL`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION_NAME`, `S3_BUCKET_NAME`.
- Реальный код S3 уже есть:
  - **Загрузка UploadFile в S3**: `backend/app/routes/personalizations.py` (`_s3_put_uploadfile`).
  - **Presigned GET**: `backend/app/routes/personalizations.py` + аналогичная логика в `backend/app/routes/catalog.py`.
  - **Чтение/запись картинок в S3** как PIL: `backend/app/tasks.py` (`_s3_read_private_to_pil`, `_s3_write_pil`).

### Текущий пайплайн персонализации (упрощённый)

- `/upload_and_analyze/`:
  - принимает фото ребёнка, **загружает в S3**, создаёт `Job` в БД, стартует `analyze_photo_task`.
- `/generate/`:
  - подтверждение, кладёт в корзину, стартует `generate_image_task`.
- `generate_image_task`:
  - читает фото ребёнка из S3,
  - для нужных иллюстраций запускает face transfer,
  - **складывает результаты в S3**: `results/{job_id}/{ill_id}.png`.
- `/result/{job_id}`:
  - отдаёт список страниц preview (берёт `BookPreview` из БД) и подменяет картинки на сгенерированные из `results/{job_id}/...` через presigned URL.

Текущее MVP/наблюдение (важно учесть в дизайне):

- **Сейчас берутся 3 фото/иллюстрации из S3**, на **всех** делается замена лица, и **все 3** выдаются как превью. Дальше это нужно обобщить на страничный граф (face/text/оба/ничего) и на частичную генерацию “до оплаты”.

**Вывод:** инфраструктура “S3 + Celery + API + ComfyUI” уже есть; нужно расширить её до полноценной книжной сборки.

---

## Что делает `html_render.py` (и что важно перенести)

`html_render.py` — CPU-скрипт, который:

- Берёт **фон** (картинка страницы) из локального каталога `page_{num}/`.
- Встраивает фон и (опционально) TTF-шрифт в HTML через **data URI**.
- Рендерит текст поверх фона через **CSS** (включая сложный `text-shadow`, близкий к Photoshop Drop Shadow).
- Делает **screenshot** через `playwright` → получает PNG фиксированного размера (по умолчанию `2551x2551`).

Ключевые нюансы для backend-версии:

- Сейчас скрипт ищет локальные файлы `page_{num}/page_{num}_text.jpg`, `Comic Sans MS.ttf` — **в репозитории этих ассетов нет**.
- В HTML текст вставляется как `{text}` без HTML-экранирования — в backend это нужно **обязательно исправить** (см. раздел “Безопасность”).
- Скрипт не делает PDF/развороты/обложку — это описано отдельно в `ts.txt` и нужно добавить в пайплайн.

---

## Требования из `ts.txt` (разложение на этапы)

### Блок (24 страницы)

- 24 страницы `page_0 ... page_23`.
- Для каждой страницы:
  - face swap (если на странице есть лицо),
  - привести к **300 DPI** и размеру **2551×2551 px**,
  - наложить текст (если есть).
- **Печать**: собрать “Блок” в PDF (в `ts.txt` есть неоднозначность — см. вопросы).
- **Превью**: страницы **1..22** собрать “по две в ряд”:
  - (1-2), (3-4), ..., (21-22).
  - `page_0` и `page_23` в превью не нужны (только печать).

Доп. требование по продуктовой логике (из текущего обсуждения):

- **До оформления заказа и оплаты** генерируем/выдаём **только первые 2 страницы** превью (см. также `ts.txt`, где “самая первая” — это crop передней обложки, и на ней “бесплатная генерация”).
- **После оплаты** генерируем остальное: весь блок/переплёт + превью 1..22 (и печатные PDF, если нужно).

### Переплёт (front_cover + back_cover)

- Передняя: face swap + resize **2800×3000 px @ 300 DPI** + текст + логотип-слой.
- Задняя: resize **2800×3000 px @ 300 DPI** + текст + логотип-слой.
- Для превью:
  - задняя: crop квадрат **2551×2551** из точки `(x=210, y=210)` → это “последняя страница” превью,
  - передняя: crop квадрат **2551×2551** из точки `(x=25, y=210)` → это “первая страница” превью (и “бесплатная генерация”).
- Печать: собрать PDF, где задняя слева, передняя справа (две 2800×3000 рядом).

---

## Главный разрыв между текущим backend и `ts.txt`

Сейчас backend генерирует отдельные картинки `results/{job_id}/{ill_id}.png` по небольшому списку `illustrations.json`.

Для требований `ts.txt` не хватает:

- **Описания книги (шаблона) на 24 страницы + обложка**: где лежат исходники, где текст, где лицо, какие стили текста.
- **Страничной “карты операций”**: где делать face swap, где делать текст, где оба шага, где ни один не нужен (страницы “только текст” и “только лицо” должны поддерживаться).
- **Нормализации DPI/размеров** (2551/2800×3000, 300 DPI).
- **Наложения текста** (Playwright-рендерер или эквивалент).
- **Сборки PDF** (блок и переплёт) и **превью-разворотов**.
- **Модели артефактов**: где хранить ссылки на готовые PDF/превью в БД и как отдавать их через API.
- **Двухфазной генерации** (до оплаты — 2 страницы, после оплаты — всё).

---

## Предлагаемая архитектура (как сделать “лучше”)

### Принцип: S3 — system of record

Все сущности, которые нужны и на вход, и на выход пайплайна:

- исходные шаблоны страниц/обложек/слоёв логотипа/шрифтов,
- промежуточные результаты (face swap),
- финальные страницы (с текстом),
- превью-развороты,
- печатные PDF,

должны иметь **детерминированные ключи** в S3.

### Принцип: разделить CPU и GPU очереди

Сейчас `celery_worker` завязан на GPU (и ComfyUI). Рендер текста и сборка PDF — CPU-задачи с тяжёлыми зависимостями (Chromium).

Рекомендация:

- Оставить `generate_image_task` (GPU/ComfyUI) в очереди `gpu`.
- Добавить отдельную очередь `render` (CPU) и отдельный воркер `celery_render_worker`.
  - Плюсы: не раздуваем GPU-образ Chromium’ом, проще масштабировать, меньше риск падений GPU-воркера из-за браузера.

### Принцип: пайплайн как цепочка Celery

Пайплайн нужно сделать “страничным” и стадийным:

- **Prepay стадия (до оплаты)**: сгенерировать только страницы, помеченные как “free/до оплаты” (требуется 2 страницы).
- **Postpay стадия (после оплаты)**: догенерировать оставшиеся страницы + собрать печатные артефакты.

С практической точки зрения это удобнее выражать как цепочки/группы Celery:

- **Prepay**: `build_pages(stage=prepay)` → (опционально) `build_preview_assets(stage=prepay)` → `finalize_stage(prepay)`
- **Postpay**: `build_pages(stage=postpay)` → `build_preview_assets(stage=postpay)` → `build_print_pdfs` → `finalize_stage(postpay)`

Важно: каждая задача должна быть **идемпотентной** (если S3-объект уже есть — не пересоздавать, либо пересоздавать по флагу).

---

## Структура данных в S3 (предлагаемый стандарт ключей)

### 1) Входные шаблоны (статические, по книге/слугу)

- `templates/{slug}/pages/page_00/base.jpg`
- `templates/{slug}/pages/page_00/logo.png` (если нужен)
- `templates/{slug}/covers/front/base.jpg`
- `templates/{slug}/covers/back/base.jpg`
- `templates/{slug}/covers/front/logo.png`
- `templates/{slug}/covers/back/logo.png`
- `templates/{slug}/fonts/comic.ttf` (или несколько)
- `templates/{slug}/manifest.json` (описание книги — см. ниже)

### 2) Артефакты job’а (динамические, по `job_id`)

- Исходное фото ребёнка (уже есть):
  - `child_photos/{job_id}_{filename}`
- Face-swap результаты (как сейчас):
  - `results/{job_id}/page_00.png` (рекомендация перейти от `ill_id` к `page_XX`)
- Нормализованные страницы (300 DPI, 2551×2551):
  - `layout/{job_id}/pages/page_00.png`
- Нормализованные обложки (2800×3000):
  - `layout/{job_id}/covers/front.png`
  - `layout/{job_id}/covers/back.png`
- Превью:
  - `preview/{job_id}/spreads/spread_01_02.png`
  - `preview/{job_id}/spreads/spread_03_04.png`
  - ...
  - `preview/{job_id}/pages/cover_front_crop.png` (первая)
  - `preview/{job_id}/pages/cover_back_crop.png` (последняя)
- Печать:
  - `print/{job_id}/block.pdf`
  - `print/{job_id}/cover.pdf`

**Почему так:** ключи становятся предсказуемыми, легко листать по префиксу и отдавать presigned URL без лишней логики.

---

## “Manifest” книги (контекст, без которого реализация будет хрупкой)

Нужен единый источник правды: **что такое книга** для конкретного `slug`.

Рекомендация: хранить `manifest.json` в S3 по `templates/{slug}/manifest.json` (и кэшировать при чтении).

### Минимальные поля манифеста

- **pages[0..23]**:
  - `page_num`: 0..23
  - `base_uri`: S3 key/uri исходной картинки (до face swap)
  - `needs_face_swap`: bool (если `false`, GPU шаг пропускается)
  - `text_layers`: список слоёв текста (может быть 0..N; если пусто — текстовый рендер пропускается)
    - `text_key`: ключ текста (например `story.page_05`)
    - `template_engine`: `"format"` / `"jinja2"` (рекомендация: безопасный шаблонизатор + последующее `html.escape`)
    - `template_vars`: какие переменные доступны (минимум `child_name`; опционально `child_age`, `child_gender`)
    - `renderer`: `"playwright"` (пока)
    - `style`: overrides (top/box_w/font_size/цвет/тени/и т.д. — как в `html_render.py`)
  - `availability`: доступность страницы по стадиям, например:
    - `{"prepay": true, "postpay": true}` для первых страниц,
    - `{"prepay": false, "postpay": true}` для “платных” страниц.
- **covers**:
  - `front.base_uri`, `back.base_uri`
  - `front.crop_preview`: `{x,y,w,h}` (2551×2551)
  - `back.crop_preview`: `{x,y,w,h}` (2551×2551)
  - `front.needs_face_swap`: bool
  - `front.text_layers`, `back.text_layers`
  - `front.logo_uri`, `back.logo_uri` (+ правила наложения: позиция/alpha)
- **output**:
  - `dpi`: 300
  - `page_size_px`: 2551
  - `cover_size_px`: `{w:2800,h:3000}`
  - `preview_spreads`: включить/выключить + правила (пары страниц)

### Источник текста

Текст может быть:

- статическим (как в `html_render.py` массив `PAGE`),
- шаблонным (подстановка имени ребёнка, возраста и т.д.),
- генерируемым моделью (уже есть Qwen/LLM компоненты, но сейчас “qwen disabled”).

В любом случае, лучше хранить **тексты как JSON** (в БД или в S3), а манифест ссылаться на ключи.

### Пример: текущий MVP на 3 изображения (face/text/оба/ничего)

Это пример того, как “текущие 3 фото из S3” превратить в расширяемый контракт, где:

- страница 1: **face + text** (и доступна в prepay),
- страница 2: **только face** (и доступна в prepay),
- страница 3: **только text** (только после оплаты),
- страница 4: **ничего не делать** (пример “пустой” страницы, только resize/нормализация; после оплаты).

```json
{
  "slug": "my-book",
  "output": {
    "dpi": 300,
    "page_size_px": 2551,
    "cover_size_px": { "w": 2800, "h": 3000 },
    "preview_spreads": true
  },
  "pages": [
    {
      "page_num": 1,
      "base_uri": "templates/my-book/pages/page_01/base.jpg",
      "needs_face_swap": true,
      "text_layers": [
        {
          "text_key": "story.page_01",
          "template_engine": "format",
          "template_vars": ["child_name"],
          "renderer": "playwright",
          "style": { "font_size": 70, "top": 451 }
        }
      ],
      "availability": { "prepay": true, "postpay": true }
    },
    {
      "page_num": 2,
      "base_uri": "templates/my-book/pages/page_02/base.jpg",
      "needs_face_swap": true,
      "text_layers": [],
      "availability": { "prepay": true, "postpay": true }
    },
    {
      "page_num": 3,
      "base_uri": "templates/my-book/pages/page_03/base.jpg",
      "needs_face_swap": false,
      "text_layers": [
        {
          "text_key": "story.page_03",
          "template_engine": "format",
          "template_vars": ["child_name"],
          "renderer": "playwright",
          "style": { "font_size": 70, "top": 700 }
        }
      ],
      "availability": { "prepay": false, "postpay": true }
    },
    {
      "page_num": 4,
      "base_uri": "templates/my-book/pages/page_04/base.jpg",
      "needs_face_swap": false,
      "text_layers": [],
      "availability": { "prepay": false, "postpay": true }
    }
  ],
  "covers": {
    "front": {
      "base_uri": "templates/my-book/covers/front/base.jpg",
      "needs_face_swap": true,
      "logo_uri": "templates/my-book/covers/front/logo.png",
      "crop_preview": { "x": 25, "y": 210, "w": 2551, "h": 2551 }
    },
    "back": {
      "base_uri": "templates/my-book/covers/back/base.jpg",
      "needs_face_swap": false,
      "logo_uri": "templates/my-book/covers/back/logo.png",
      "crop_preview": { "x": 210, "y": 210, "w": 2551, "h": 2551 }
    }
  }
}
```

---

## План реализации (пошагово)

### Этап 0 — уточнения (чтобы не сделать неверно)

Нужно подтвердить/уточнить:

- **Что именно считается “первыми 2 страницами” до оплаты**:
  - вариант А (строго по `ts.txt`): `cover_front_crop` = страница 1 + дальше `spread_01_02` как страница 2,
  - вариант Б: две отдельные страницы `page_01` и `page_02` (без разворота),
  - вариант В: `cover_front_crop` + `page_01` (если “страница 1” — обложка, а “страница 2” — первая страница блока).
- **PDF блока**: это один `block.pdf` на 24 страницы или 24 отдельных PDF “по 1 странице”?
- **Где лежат исходники** `page_*`, `front_cover`, `back_cover`, логотипы и шрифты:
  - уже в S3? в каком бакете/префиксе?
  - или должны быть загружены из локальной папки в S3 “первичной загрузкой”?
- **Какие страницы содержат текст** и как определяется текст (статический vs шаблонный vs генерируемый).
- **Нужна ли нумерация/вылеты/bleed** для типографии (часто требуется больше, чем 2551×2551).
- **Цветовой профиль** (sRGB/CMYK) для печати — сейчас пайплайн предполагает PNG/JPG без ICC.

### Этап 1 — формализовать шаблоны

- Согласовать структуру `templates/{slug}/...` и манифест.
- Подготовить скрипт/процедуру загрузки ассетов в S3 (одноразово или как CI job).
- Привести иллюстрации к нужным размерам или хранить “как есть” и нормализовать на лету (предпочтительнее хранить оригиналы + нормализовать в пайплайне).

### Этап 2 — рендер текста (перенос логики `html_render.py`)

- Вынести из `html_render.py` концепцию “рендерер текста поверх картинки”:
  - вход: bytes/URI фоновой картинки + текст + стиль,
  - выход: PNG bytes.
- Важно:
  - **HTML-экранирование текста**,
  - запрет внешних ресурсов (только `data:`),
  - переиспользование одного browser instance на job (ускорение).

Отдельно (новое требование): **подстановка имени ребёнка из backend-запроса**.

- Шаблоны текста должны поддерживать переменные (минимум `child_name`).
- Последовательность для безопасности: `template_render(text, vars)` → **plain text** → `html.escape(plain text)` → вставка в HTML.

Технические изменения (план):

- Добавить зависимости:
  - `playwright` (Python),
  - системные зависимости для Chromium,
  - установка браузера (`python -m playwright install chromium`) на этапе сборки образа `render_worker`.
- Добавить отдельный Celery воркер `celery_render_worker` (CPU, очередь `render`).

### Этап 3 — нормализация DPI/размеров

Для страниц:

- привести каждую итоговую страницу к `2551×2551`,
- проставить DPI=300 в метаданных при сохранении (Pillow поддерживает `save(..., dpi=(300,300))` для некоторых форматов),
- зафиксировать формат (PNG для качества; для печати иногда лучше TIFF/PDF — уточняется).

Для обложек:

- привести к `2800×3000`,
- наложить текст и логотип,
- сделать crop превью согласно координатам из `ts.txt`.

### Этап 4 — превью-развороты

- Собрать пары страниц:
  - 1–2, 3–4, ..., 21–22 в одно изображение “в ряд”.
- Добавить в начало превью `front_cover` crop, в конец `back_cover` crop.
- Сложить всё в `preview/{job_id}/...` и отдавать через presigned URL.

Двухфазность:

- На стадии **prepay** собирать/выдавать только первые 2 “страницы превью” (как согласовано в Этапе 0).
- На стадии **postpay** — полный набор превью (1..22 + обложки, если так требуется продуктом).

### Этап 5 — печатные PDF

- `block.pdf`:
  - либо 24 страницы внутри одного PDF,
  - либо 24 отдельных PDF — уточнить по типографии/ТЗ.
- `cover.pdf`:
  - одна страница шириной 5600 и высотой 3000, где слева back, справа front.

Рекомендованный подход:

- Генерировать PDF **из финальных PNG** (после текста/лого), чтобы типография получила то же, что и превью (с исключением crop’ов).
- Использовать библиотеку, которая корректно задаёт размер страницы в физических единицах (points) и не “пересэмпливает” картинки.

### Этап 6 — API и модель артефактов

Так как фронтенда нет, нужны **явные API-методы** для получения результатов:

- `POST /personalizations/{job_id}/build_preview` (prepay):
  - принимает `child_name` (и опционально `child_age`, `child_gender`),
  - запускает генерацию **только первых 2 страниц** (stage=prepay),
  - возвращает статус/артефакты prepay превью.
- `POST /personalizations/{job_id}/build_full` (postpay):
  - вызывается **после подтверждения оплаты** (вручную админкой/сервисом платежей/джобой),
  - догенерирует оставшиеся страницы (stage=postpay) + PDF.
- `GET /personalizations/{job_id}/artifacts`:
  - параметр `stage=prepay|postpay` (или две секции в ответе),
  - для `prepay` — только первые 2 страницы,
  - для `postpay` — весь набор (превью + PDF),
  - ссылки на `print/block.pdf`, `print/cover.pdf`,
  - список превью-разворотов,
  - список финальных страниц (опционально).
- (Опционально) `POST /personalizations/{job_id}/build_print` / `.../build_preview`:
  - ручной запуск пересборки (если нужно).

Замечание по совместимости с текущим backend:

- Сейчас `child_name` передаётся в `POST /generate/` (и это происходит **до оплаты**). Если важно минимизировать изменения контракта API, то `POST /generate/` можно переопределить как “запустить **prepay** генерацию (2 страницы)”, а полный пайплайн вынести в отдельный postpay-триггер (вебхук оплаты/админский endpoint/фоновая джоба).

Хранение в БД:

- Либо расширить `Job` (добавить поля `print_block_uri`, `print_cover_uri`, `preview_prefix`, `layout_status`),
- Либо отдельная таблица `JobArtifact` (гибче, лучше для будущего).

### Этап 7 — наблюдаемость и эксплуатация

- Логи по шагам пайплайна + `job_id` в каждом сообщении.
- Метрики (время на страницу, время на PDF).
- Retention policy в S3 (сколько хранить промежуточные артефакты).

---

## Безопасность (важно для Playwright-рендера)

Основные риски и меры:

- **HTML/JS injection** через текст (имя ребёнка и т.п.):
  - обязательно `html.escape()` для текста,
  - запретить/не использовать `innerHTML`,
  - ограничить длину текста, валидировать символы.
- **Внешние запросы браузера**:
  - все ресурсы должны быть `data:` или локальные,
  - запретить навигации/requests (route interception) — чтобы Chromium не лез в интернет.
- **Изоляция**:
  - отдельный CPU-воркер, минимальные права, no-root по возможности.

---

## Риски/узкие места и как их закрыть

- **Playwright + Chromium внутри текущего CUDA-образа**:
  - может потребовать много системных пакетов и сильно увеличить image size.
  - решение: отдельный `render_worker` образ (CPU) или multi-stage.
- **Отсутствие ассетов в репозитории** (`page_*`, `.ttf`):
  - решение: “manifest + templates в S3” как обязательный контракт.
- **Детерминизм рендера текста**:
  - разные версии Chromium/шрифтов могут чуть менять кернинг.
  - решение: фиксировать версии Playwright/Chromium и хранить шрифт в S3.
- **Производительность** (24 страницы + обложка):
  - решение: переиспользовать один браузер на job, батчить операции, ограничить параллелизм.

---

## Короткий чек-лист “что нужно на вход реализации”

- Доступы к S3 (endpoint, keys, bucket).
- Набор шаблонов книги (страницы 0..23, cover front/back, logo layers, font).
- Manifest на каждый `slug`.
- Ответы на вопросы из “Этап 0”.

---

## Рекомендуемые следующие шаги (минимальный старт)

- Согласовать формат `manifest.json` и структуру S3 ключей.
- Поднять отдельный `celery_render_worker` (пока без PDF, только рендер текста поверх одной страницы).
- Протянуть артефакт в S3 и presigned URL через новый endpoint `/artifacts`.
- После стабилизации — добавить превью-развороты и PDF.


